<!DOCTYPE html>
<html>
<head>
    <title>Cellphone Survivor v3 Chaos - Texturas</title>
    <style>
        /* Estilos base */
        body {
            background:#346;
            margin:0;
            overflow:hidden;
            display:flex;
            justify-content:center;
            align-items:center;
            height:100vh;
            width:100vw;
            font-family:sans-serif;
            color:white;
        }
        canvas {
            background:#346;
            display:block;
            border:2px solid #555;
            touch-action:none;
            max-width: 100%;
            max-height: 100%;
        }
        /* UI HUD */
        #ui-overlay{
            position:absolute;
            top:0;
            left:0;
            width:100%;
            padding:15px;
            box-sizing:border-box;
            display:flex;
            justify-content:space-between;
            align-items:flex-start;
            pointer-events:none;
            font-size: 1.6em;
        }
        #score,#level-info,#shield-bar,#special-bar{
            background:rgba(0,0,0,0.7);
            padding:12px 20px;
            border-radius:8px;
            margin-bottom:10px;
            pointer-events:auto;
        }
        /* Telas Modais (Level Up, Menu) */
        .modal-screen {
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%);
            background:rgba(0,0,0,0.95);
            padding:30px;
            border-radius:15px;
            text-align:center;
            z-index:100;
            width:90%;
            max-width:500px;
            box-shadow:0 0 30px rgba(255,255,255,0.3);
        }
        .upgrade-button, .menu-button{
            display:block;
            width:100%;
            padding:18px;
            margin-bottom:12px;
            background-color:#4CAF50;
            color:white;
            border:none;
            border-radius:8px;
            font-size:1.2em;
            cursor:pointer;
            pointer-events:auto;
            transition: background-color 0.2s;
        }
        .upgrade-button:hover, .menu-button:hover{background-color:#45a049;}
        
        /* Controles de Ação */
        #controls-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        .action-button {
            padding: 20px 35px;
            font-size: 1.3em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            opacity: 0.8;
            transition: opacity 0.2s, background-color 0.2s;
        }
        .action-button:hover {
            opacity: 1.0;
        }
        #shield-button {
            background-color: #007bff;
        }
        #special-button {
            background-color: #ffc107;
            color: #333;
        }
        .action-button:disabled {
            background-color: #6c757d;
            cursor: default;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="main-menu" class="modal-screen">
        <h1>ROGUE.io</h1>
        <p>Use o mouse ou toque para mover.</p>
        <button id="start-game-button" class="menu-button">Carregando Texturas...</button>
        <h3>Controles Especiais:</h3>
        <p>Z ou Botão Azul: Escudo (Shield)</p>
        <p>X ou Botão Amarelo: Especial (Special)</p>
    </div>

    <div id="ui-overlay" style="display:none;">
        <div>
            <div id="score">SCORE: 0</div>
            <div id="level-info">LVL: 1 | XP: 0 | Wave: 1</div>
        </div>
        <div>
            <div id="shield-bar">SHIELD: 0%</div>
            <div id="special-bar">SPECIAL: 0%</div>
        </div>
    </div>
    
    <div id="controls-container" style="display:none;">
        <button id="shield-button" class="action-button">SHIELD (Z)</button>
        <button id="special-button" class="action-button">SPECIAL (X)</button>
    </div>
    
    <div id="level-up-screen" class="modal-screen" style="display:none;">
        <h2>LEVEL UP! Choose an upgrade:</h2>
        <div id="upgrade-options"></div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const levelInfoDisplay = document.getElementById('level-info');
const shieldBar = document.getElementById('shield-bar');
const specialBar = document.getElementById('special-bar');
const levelUpScreen = document.getElementById('level-up-screen');
const upgradeOptionsDiv = document.getElementById('upgrade-options');
const shieldButton = document.getElementById('shield-button');
const specialButton = document.getElementById('special-button');
const mainMenu = document.getElementById('main-menu');
const startGameButton = document.getElementById('start-game-button');
const uiOverlay = document.getElementById('ui-overlay');
const controlsContainer = document.getElementById('controls-container');

let gameActive=false, lastTime=0;

// Configuração para Tela Cheia
const SCREEN_W=window.innerWidth;
const SCREEN_H=window.innerHeight;
canvas.width=SCREEN_W; 
canvas.height=SCREEN_H;

// --- 1. CARREGAMENTO DE TEXTURAS ---
const textures = {};
let assetsLoaded = 0;
// ⚠️ ATUALIZE ESTE NÚMERO SE ADICIONAR MAIS TEXTURAS
const totalAssets = 5; 

// Função de Carregamento
function loadTexture(name, src) {
    const img = new Image();
    img.onload = () => {
        assetsLoaded++;
        if (assetsLoaded === totalAssets) {
            console.log("Todas as texturas carregadas!");
            startGameButton.disabled = false;
            startGameButton.textContent = "COMEÇAR JOGO";
        }
    };
    img.onerror = () => {
        console.error(`Falha ao carregar textura: ${src}. Usando fallback de cor.`);
        textures[name] = null; // Marca como nulo para usar a cor fallback
        assetsLoaded++;
    };
    img.src = src;
    textures[name] = img;
}

// 2. LISTA DE TEXTURAS A SEREM CARREGADAS
// ❗ POR FAVOR, COLOQUE SEUS ARQUIVOS DE IMAGEM NESTA MESMA PASTA
loadTexture('player', 'player.png');             
loadTexture('enemy_blue', 'enemy_blue.png');     
loadTexture('enemy_yellow', 'enemy_yellow.png'); 
loadTexture('enemy_red', 'enemy_red.png');       
loadTexture('projectile', 'projectile.png');     

startGameButton.disabled = true; // Desabilita o botão até carregar

// --- DADOS E VARIÁVEIS DO JOGO ---
let player={};
let projectiles=[], enemies=[], xpGems=[];
let wave=1, enemiesPerWave=5;
let touchStart={x:0,y:0}, touchCurrent={x:0,y:0}, isTouching=false;
let enemySpawnTimer=0;
const ENEMY_SPAWN_RATE=5; 

// --- FUNÇÃO PARA INICIALIZAR O JOGO ---
function initGame() {
    // Resetar o estado do jogador
    player = {
        x:SCREEN_W/2, y:SCREEN_H/2, radius:30, speed:150,
        dx:0, dy:0, score:0, health:10, level:1, xp:0, xpToNextLevel:5,
        stats:{projectileDamage:4,projectileSpeed:400,projectileInterval:1.5,projectileSize:7,projectileDuration:2,moveSpeed:2,shotCount:1},
        attackTimer:0, shield:0, shieldMax:100, special:0, specialMax:100, shieldActive:false, specialActive:false
    };
    
    // Resetar entidades
    projectiles = [];
    enemies = [];
    xpGems = [];
    wave = 1;
    enemiesPerWave = 5;
    enemySpawnTimer = 0;

    // Esconder Menu e Mostrar HUD
    mainMenu.style.display = 'none';
    uiOverlay.style.display = 'flex';
    controlsContainer.style.display = 'flex';
    
    // Iniciar o jogo
    gameActive = true;
    lastTime = performance.now();
    
    // Spawnar a primeira wave
    nextWave();
}

// --- EVENT LISTENERS E CONTROLES (MANTIDOS) ---
canvas.addEventListener('mousedown', e=>{if(!gameActive)return; isTouching=true; const rect=canvas.getBoundingClientRect(); touchStart.x=(e.clientX-rect.left); touchStart.y=(e.clientY-rect.top); touchCurrent.x=touchStart.x; touchCurrent.y=touchStart.y;});
canvas.addEventListener('mousemove', e=>{if(!isTouching)return; const rect=canvas.getBoundingClientRect(); touchCurrent.x=(e.clientX-rect.left); touchCurrent.y=(e.clientY-rect.top);});
canvas.addEventListener('mouseup', e=>{isTouching=false; player.dx=0; player.dy=0;});
canvas.addEventListener('touchstart', e=>{e.preventDefault(); if(!gameActive)return; isTouching=true; const rect=canvas.getBoundingClientRect(); touchStart.x=(e.touches[0].clientX-rect.left); touchStart.y=(e.touches[0].clientY-rect.top); touchCurrent.x=touchStart.x; touchCurrent.y=touchStart.y;});
canvas.addEventListener('touchmove', e=>{e.preventDefault(); if(!isTouching)return; const rect=canvas.getBoundingClientRect(); touchCurrent.x=(e.touches[0].clientX-rect.left); touchCurrent.y=(e.touches[0].clientY-rect.top);});
canvas.addEventListener('touchend', e=>{isTouching=false; player.dx=0; player.dy=0;});

startGameButton.onclick = initGame;

function activateShield() {
    if(player.shield >= player.shieldMax && gameActive) {
        player.shieldActive = true; 
        player.shield = 0;
    }
}
function activateSpecial() {
    if(player.special >= player.specialMax && gameActive) {
        player.specialActive = true; 
        player.special = 0;
    }
}

shieldButton.onclick = activateShield;
specialButton.onclick = activateSpecial;

window.addEventListener('keydown', e=>{
    if(!gameActive) return;
    if(e.key==='z' || e.key==='Z') activateShield();
    if(e.key==='x' || e.key==='X') activateSpecial();
});

function spawnEnemy(type='blue',isBoss=false){
    let x,y,size=isBoss?60:30;
    let edge=Math.floor(Math.random()*4);
    switch(edge){case 0:x=Math.random()*SCREEN_W;y=-size;break;case 1:x=SCREEN_W+size;y=Math.random()*SCREEN_H;break;case 2:x=Math.random()*SCREEN_W;y=SCREEN_H+size;break;case 3:x=-size;y=Math.random()*SCREEN_H;break;}
    let color=type;
    let speed=type==='yellow'?70:(isBoss?60:90);
    let health=isBoss?200:6;
    enemies.push({x,y,radius:size,health,speed,color,isBoss,type,attackTimer:0, maxHealth: health});
}

function createProjectile(){
    let targets=enemies.filter(e=>e); 
    if(targets.length==0) return;
    
    let nearestTarget = targets.reduce((nearest, current) => {
        const distSqCurrent = (current.x - player.x)**2 + (current.y - player.y)**2;
        if (!nearest || distSqCurrent < nearest.distSq) {
            return {enemy: current, distSq: distSqCurrent};
        }
        return nearest;
    }, null)?.enemy;

    if (!nearestTarget) return;

    for(let s=0;s<player.stats.shotCount;s++){
        const angle=Math.atan2(nearestTarget.y-player.y,nearestTarget.x-player.x);
        const spread=(s-((player.stats.shotCount-1)/2))*0.08;
        const size=player.stats.projectileSize;
        projectiles.push({x:player.x,y:player.y,dx:Math.cos(angle+spread)*player.stats.projectileSpeed,dy:Math.sin(angle+spread)*player.stats.projectileSpeed,radius:size,damage:player.stats.projectileDamage,lifetime:player.stats.projectileDuration, fromPlayer: true});
    }
}

function spawnXPGem(x,y, value=1){xpGems.push({x,y,radius:6,value,active:true});}

function nextWave(){
    wave++;
    enemiesPerWave=10 + Math.floor(player.level * 2); 
    
    for(let i=0;i<enemiesPerWave;i++){
        let type='blue';
        if(Math.random() < (0.1 + player.level * 0.01)) type='yellow'; 
        spawnEnemy(type);
    }
    if(wave%5==0) spawnEnemy('red',true); 
}

function checkLevelUp(){
    if(player.xp>=player.xpToNextLevel){
        player.xp-=player.xpToNextLevel;
        player.level++;
        player.xpToNextLevel=Math.floor(player.xpToNextLevel*1.5);
        gameActive=false; 
        showLevelUpScreen();
    }
}

function showLevelUpScreen(){
    upgradeOptionsDiv.innerHTML='';
    levelUpScreen.style.display='block';
    uiOverlay.style.display = 'none';
    controlsContainer.style.display = 'none';
    
    const upgrades=[
        {name:'Damage +1 (Dano)',effect:()=>player.stats.projectileDamage+=1},
        {name:'Speed +10% (Velocidade)',effect:()=>player.stats.moveSpeed+=0.1},
        {name:'Fire Rate -10% (Cadência)',effect:()=>player.stats.projectileInterval=Math.max(0.3,player.stats.projectileInterval*0.9)},
        {name:'Health +5 (Vida Max)',effect:()=>player.health+=5},
        {name:'Shot Count +1 (Tiros)',effect:()=>player.stats.shotCount+=1},
        {name:'Shield Max +20',effect:()=>player.shieldMax+=20},
        {name:'Special Max +20',effect:()=>player.specialMax+=20}
    ];
    upgrades.sort(()=>0.5-Math.random());
    const options=upgrades.slice(0,3);
    options.forEach(u=>{
        const button=document.createElement('button');
        button.className='upgrade-button';
        button.textContent=u.name;
        button.onclick=()=>{
            u.effect();
            levelUpScreen.style.display='none';
            uiOverlay.style.display = 'flex';
            controlsContainer.style.display = 'flex';
            gameActive=true;
            lastTime = performance.now();
        };
        upgradeOptionsDiv.appendChild(button);
    });
}

function update(deltaTime){
    if(!gameActive)return;

    let moveX=0,moveY=0;
    if(isTouching){
        let dirX=touchCurrent.x-touchStart.x;
        let dirY=touchCurrent.y-touchStart.y;
        const mag=Math.sqrt(dirX*dirX+dirY*dirY);
        if(mag>10){moveX=dirX/mag; moveY=dirY/mag;}
    }
    player.x+=moveX*player.speed*player.stats.moveSpeed*deltaTime;
    player.y+=moveY*player.speed*player.stats.moveSpeed*deltaTime;
    player.x=Math.max(player.radius,Math.min(SCREEN_W-player.radius,player.x));
    player.y=Math.max(player.radius,Math.min(SCREEN_H-player.radius,player.y));

    enemySpawnTimer+=deltaTime;
    if(enemies.length === 0 && enemySpawnTimer >= 1) { 
        nextWave();
        enemySpawnTimer=0;
    } else if (enemies.length === 0 && enemySpawnTimer >= ENEMY_SPAWN_RATE) {
        nextWave();
        enemySpawnTimer=0;
    }
    
    player.attackTimer+=deltaTime;
    if(player.attackTimer>=player.stats.projectileInterval){
        createProjectile(); 
        player.attackTimer=0;
    }

    for(let i=projectiles.length-1;i>=0;i--){
        let p=projectiles[i];
        p.x+=p.dx*deltaTime; p.y+=p.dy*deltaTime; p.lifetime-=deltaTime;
        
        if(p.lifetime<=0){projectiles.splice(i,1); continue;}
        
        if (p.fromPlayer) {
            for(let j=enemies.length-1;j>=0;j--){
                let e=enemies[j];
                const distSq=(p.x-e.x)**2+(p.y-e.y)**2;
                if(distSq<(p.radius+e.radius)**2){
                    e.health-=p.damage;
                    projectiles.splice(i,1); i--;
                    if(e.health<=0){
                        if(e.isBoss) spawnXPGem(e.x,e.y, 5);
                        else if(e.type==='yellow') spawnXPGem(e.x,e.y, 2); 
                        else spawnXPGem(e.x,e.y, 1);
                        player.score+=e.isBoss?100:10;
                        enemies.splice(j,1);
                    }
                    break;
                }
            }
        } 
        else {
            const distSq=(p.x-player.x)**2+(p.y-player.y)**2;
            if(distSq<(p.radius+player.radius)**2){
                if(!player.shieldActive){
                    player.health-=p.damage;
                    if(player.health<=0){gameActive=false; 
                        uiOverlay.style.display = 'none';
                        controlsContainer.style.display = 'none';
                        alert(`Game Over! Score: ${player.score}`);
                        mainMenu.style.display = 'block';
                    }
                }
                projectiles.splice(i,1);
                i--;
            }
        }
    }

    for(let i=enemies.length-1;i>=0;i--){
        let e=enemies[i];
        const angle=Math.atan2(player.y-e.y,player.x-e.x);
        
        if(e.type==='yellow'){
            e.attackTimer+=deltaTime;
            const distToPlayer = Math.sqrt((player.x-e.x)**2+(player.y-e.y)**2);
            const attackRange = 250; 
            
            if(distToPlayer > attackRange * 1.1) {
                e.x+=Math.cos(angle)*e.speed*deltaTime;
                e.y+=Math.sin(angle)*e.speed*deltaTime;
            } else if (distToPlayer < attackRange * 0.9) {
                e.x-=Math.cos(angle)*e.speed*deltaTime * 0.5;
                e.y-=Math.sin(angle)*e.speed*deltaTime * 0.5;
            }
            
            if(e.attackTimer>2) {
                let dx=Math.cos(angle)*200; let dy=Math.sin(angle)*200;
                projectiles.push({x:e.x,y:e.y,dx,dy,radius:8,damage:1,lifetime:3, color: 'orange'}); 
                e.attackTimer=0;
            }

        } else {
            e.x+=Math.cos(angle)*e.speed*deltaTime;
            e.y+=Math.sin(angle)*e.speed*deltaTime;
        }

        const distSq=(player.x-e.x)**2+(player.y-e.y)**2;
        if(distSq<(player.radius+e.radius)**2){
            if(!player.shieldActive){
                player.health--; 
                if(e.type !== 'yellow' || Math.random() < 0.2) enemies.splice(i,1); 
                
                if(player.health<=0){gameActive=false; 
                    uiOverlay.style.display = 'none';
                    controlsContainer.style.display = 'none';
                    alert(`Game Over! Score: ${player.score}`);
                    mainMenu.style.display = 'block';
                }
            }
        }
    }

    for(let i=xpGems.length-1;i>=0;i--){
        let g=xpGems[i];
        let dist=Math.sqrt((player.x-g.x)**2+(player.y-g.y)**2);
        if(dist<150){const angle=Math.atan2(player.y-g.y,player.x-g.x); g.x+=Math.cos(angle)*300*deltaTime; g.y+=Math.sin(angle)*300*deltaTime;}
        if(dist<player.radius+g.radius){player.xp+=g.value; xpGems.splice(i,1); checkLevelUp();}
    }
    
    if(!player.shieldActive) player.shield=Math.min(player.shieldMax,player.shield+20*deltaTime);
    if(!player.specialActive) player.special=Math.min(player.specialMax,player.special+10*deltaTime);

    if(player.specialActive){
        enemies.forEach(e=>{
            const dx=e.x-player.x, dy=e.y-player.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist<300){
                e.x+=dx/dist*500*deltaTime; e.y+=dy/dist*500*deltaTime;
            }
        });
        player.specialActive=false; 
    }

    if(player.shieldActive){
        player.shieldActive=false; 
    }
    
    shieldButton.disabled = player.shield < player.shieldMax;
    specialButton.disabled = player.special < player.specialMax;
    
    shieldButton.textContent = `SHIELD (Z) [${Math.floor(player.shield)}/${player.shieldMax}]`;
    specialButton.textContent = `SPECIAL (X) [${Math.floor(player.special)}/${player.specialMax}]`;

    scoreDisplay.textContent=`SCORE: ${player.score} | HEALTH: ${player.health}`;
    levelInfoDisplay.textContent=`LVL: ${player.level} | XP: ${player.xp}/${player.xpToNextLevel} | Wave: ${wave}`;
    shieldBar.textContent=`SHIELD: ${Math.floor(player.shield)}%`;
    specialBar.textContent=`SPECIAL: ${Math.floor(player.special)}%`;
}


// --- FUNÇÃO DRAW AGORA DESENHA AS TEXTURAS ---
function draw(){
    ctx.clearRect(0,0,SCREEN_W,SCREEN_H);
    if (!gameActive && mainMenu.style.display !== 'block' && levelUpScreen.style.display !== 'block') {
        return; 
    }

    // XP Gems (Mantidas como círculos verdes)
    xpGems.forEach(g=>{ctx.fillStyle='lime'; ctx.beginPath(); ctx.arc(g.x,g.y,g.radius,0,Math.PI*2); ctx.fill();});
    
    // Projectiles
    projectiles.forEach(p=>{
        const size = p.radius * 2;
        const texture = p.fromPlayer ? textures['projectile'] : null;

        if (texture) {
            ctx.drawImage(texture, p.x - p.radius, p.y - p.radius, size, size);
        } else {
            // Fallback para círculo (usado para tiros inimigos e falha de carregamento)
            ctx.fillStyle=p.color || (p.fromPlayer?'cyan':'orange'); 
            ctx.beginPath(); 
            ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); 
            ctx.fill();
        }
    });
    
    // Enemies
    enemies.forEach(e=>{
        const size = e.radius * 2;
        let texture = null;
        if (e.isBoss) {
            texture = textures['enemy_red'];
        } else if (e.type === 'yellow') {
            texture = textures['enemy_yellow'];
        } else {
            texture = textures['enemy_blue'];
        }
        
        if (texture) {
            ctx.drawImage(texture, e.x - e.radius, e.y - e.radius, size, size);
        } else {
            // Fallback para círculo
            ctx.fillStyle=e.color; 
            ctx.beginPath(); 
            ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); 
            ctx.fill();
        }

        // Barra de Vida do Boss
        if(e.isBoss){
            const barW=e.radius*2; const barH=5;
            ctx.fillStyle='#333';
            ctx.fillRect(e.x-barW/2,e.y-e.radius-barH-2,barW,barH);
            ctx.fillStyle='red';
            ctx.fillRect(e.x-barW/2,e.y-e.radius-barH-2,barW*(e.health/e.maxHealth),barH);
        }
    });

    // Player
    if (gameActive || levelUpScreen.style.display === 'block') {
        // Shield Efeito
        if(player.shieldActive || player.shield >= player.shieldMax) {
            ctx.fillStyle='rgba(0, 123, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        const size = player.radius * 2;
        const texture = textures['player'];

        if (texture) {
            ctx.drawImage(texture, player.x - player.radius, player.y - player.radius, size, size);
        } else {
            // Fallback para círculo
            ctx.fillStyle='white'; 
            ctx.beginPath(); 
            ctx.arc(player.x,player.y,player.radius,0,Math.PI*2); 
            ctx.fill();
        }
    }
    
    // Indicador de toque/movimento
    if(isTouching && gameActive) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(touchStart.x, touchStart.y, 40, 0, Math.PI * 2);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(touchStart.x, touchStart.y);
        ctx.lineTo(touchCurrent.x, touchCurrent.y);
        ctx.stroke();
    }
}

function gameLoop(currentTime){
    const deltaTime=(currentTime-lastTime)/1000;
    lastTime=currentTime;
    update(deltaTime); 
    draw();
    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
